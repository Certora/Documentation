% DO NOT EDIT; this file is automatically generated
% To change the documentation or examples, modify the [CVLErrorExample] annotation on the corresponding class.
% To regenerate, run the `main` method in `ErrorDocGenerator.kt`

List of CVL errors
==================

```{contents}
```


## Basic syntax errors


### `ArraySizeMustBeLiteral`

>
> Static array sizes must be number literals, such as `0` or `10`.  More complex expressions are not allowed.
>
> *No example provided*


### `CVLTypeHasLocation`

>
> Locations are only allowed in contexts that refer to Solidity types directly, such as methods block entry arguments, methods block return types, and hook arguments.  See {ref}`type-conversions` for additional information.
>
> *No example provided*


### `DuplicatePreserved`

>
> You may have at most one {ref}`preserved` for each method, at most one generic `preserved` block, and at
> most one `fallback` preserved block.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> invariant i() true {
>     preserved { }
>     preserved  { }
> }
> ```
> ```
> Example:3:13: Invariant `i` has multiple generic preserved blocks (additional block on line 4)
> ```


### `InvalidCatchAllFlag`

>
> The annotations that follow the `returns` clause in a methods-block entry (such as {ref}`optional` and
> {ref}`envfree`) only make sense for specific contract functions.  Therefore, their use in catch-all
> summaries of the form `function C._` are disallowed.  If you really want to declare every function `envfree`,
> you will need to add a separate entry for each function.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function C._ envfree => NONDET;
> }
> ```
> ```
> Example:3:26: Catch-all methods entries of the form `function f._` cannot be marked `envfree`
> ```


### `LhsIsDynamicArray`

>
> CVL does not support assigning to an entire array; you can only assign to an entry with a specific index.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> rule example {
>     x[] = 2;
> }
> ```
> ```
> Example:3:17: Assigning to an array element requires an index
> ```


### `LhsIsMapping`

>
> CVL does not support assigning to an entire mapping; you must give individual assignments for the needed elements.
>
> *No example provided*


### `ReservedKeywordAsFunction`

>
> This error indicates that you tried to use a cast where a function call was expected.  If you want to call a
> contract function with the same name as a keyword, you will need to add a harness function to your contract with
> a different name.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> rule example {
>     uint result = assert_uint256();
> }
> ```
> ```
> Example:3:27: `assert_uint256` is a reserved CVL keyword. Usage: `assert_uint256(valToConvert)`
> ```


### `SyntaxError`

>
> A syntax error indicates a misplaced symbol that prevents the CVL compiler from interpreting a spec file.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 1-1
> 
> rule example oopsie { }
> ```
> ```
> Example:2:22: Syntax error: unexpected token near `oopsie`
> ```


### `TwoStateOnNonGhostFunction`

>
> You can only use `f@old` or `f@new` in the context of a `havoc...assuming` statement, and it can only be applied to a ghost.  See {ref}`havoc-stmt` for more information.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 5-5
> 
> function f(uint x) returns uint {
>     return x;
> }
> rule example {
>     uint y = f@old(0);
> }
> ```
> ```
> Example:6:22: Cannot use `@old` with non-ghost function `f`
> ```


### `WithWrongNumberArguments`

>
> A `with` must have the form `with(env <variable-name>)`.  See {ref}`with-env` or {ref}`preserved` for more information.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function externalFunction() external with() => summary(e1, e2);
> }
> ```
> ```
> Example:3:50: `with` clause has 0 arguments; `with` clauses must define a single argument of type `env` (e.g. `with(env e)`)
> ```


### `WithWrongType`

>
> A `with` must have the form `with(env <variable-name>)`.  See {ref}`with-env` or {ref}`preserved` for more information.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function externalFunction() external with(uint256 x) => summary(x);
> }
> 
> function summary(uint256 x) {}
> ```
> ```
> Example:3:50: `with` clause argument has type `uint256`; `with` clauses must define a single argument of type `env` (e.g. `with(env e)`)
> ```



## Type-checking errors


### `AssignedToKeyword`

>
> CVL keywords cannot be assigned to.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 1-1
> 
> function f() { nativeBalances = 0; }
> ```
> ```
> Example:2:24: The special CVL variable `nativeBalances` cannot be assigned to.
> ```


### `DeclaredKeyword`

>
> CVL does not allow declaring variables with the same names as keywords.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> function f() {
>     mathint nativeBalances = 0;
> }
> ```
> ```
> Example:3:13: `nativeBalances` is a CVL keyword and cannot be redeclared
> ```


### `InconsistentVariableDefinition`

>
> You are allowed to declare a variable and then define it inside the branches of an `if` block.  If you define it
> in one branch, however, you must also define it in the other branch.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 3-7
> 
> function f(bool flag) {
>     mathint x;
>     if (flag) {
>         x = 5;
>     } else {
>         assert true;
>     }
> }
> ```
> ```
> Example:4:13: `x` is defined in the `if` branch (on line 5) but not in the `else` branch
> ```


### `NoValidInstantiationsLeft`

>
> A filter for some method parameter filters out all candidates.
>
> *No example provided*


### `UndeclaredVariable`

>
> All CVL variables must be declared before they are used
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> function f() {
>     mathint y = 2 * x;
> }
> ```
> ```
> Example:3:25: Variable `x` has not been declared.
> ```



## Methods-block errors


### `EnvfreeAndWith`

>
> {ref}`envfree` indicates that a method does not depend on its environment, while a {ref}`with-env`
> allows a function summary to depend on its environment.  Therefore, we disallow including both annotations on
> the same method.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function externalFunction() external envfree with(env e) => summary(e);
> }
> 
> function summary(env e) {}
> ```
> ```
> Example:3:58: `envfree` methods-block entries must not declare a `with(env ...)` clause
> ```


### `InvalidSummaryForWithClause`

>
> {ref}`with-env` bind a variable name for use in a function summary; without a function summary the clause
> serves no purpose.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function externalFunction() external with(env e) => NONDET;
> }
> ```
> ```
> Example:3:50: `with(...)` clauses are only allowed for methods-block entries with function summaries.
> ```



## CVL 2 errors


### `CVL2MissingFunctionKW`

>
> Since CVL 2, methods block entries must begin with `function`.  See {ref}`cvl2-function-keyword`.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     balanceOf(address);
> }
> ```
> ```
> Example:3:17: Since CVL 2, methods block entries must begin with `function`
> ```


### `CVL2MissingSemicolon`

>
> Indicates one of the places that CVL became more strict about the placement of semicolons.  See {ref}`cvl2-semicolons`.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function balanceOf(address)
> }
> ```
> ```
> Example:3:40: Since CVL 2, methods block entries must end with `;`
> ```



## Unsupported feature errors


### `AssignedAfterUse`

>
> In CVL, non-ghost variables cannot be given new values once they have been read.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 4-4
> 
> function f() {
>     mathint x;
>     mathint y = x * x;
>     x = 3;
> }
> ```
> ```
> Example:5:13: Assigning to a CVL variable after it is accessed is disallowed; `x` was previously used on line 4.
> ```


### `DuplicateDeclaration`

>
> If a CVL variable is defined in a scope, it cannot be redefined.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> function f(mathint x) {
>     uint x = 5;
> }
> ```
> ```
> Example:3:13: Redeclaring variables is not supported; `x` was previously declared on line 2
> ```


