% DO NOT EDIT; this file is automatically generated
% To change the documentation or examples, modify the [CVLErrorExample] annotation on the corresponding class.
% To regenerate, run the `main` method in `ErrorDocGenerator.kt`

List of CVL errors
==================

```{contents}
```


## Basic syntax errors


### `ApplyExpWithAtNewOrAtOldBase`

>
> One cannot use the `@old` or `@new` notation on a contract instance.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> rule r {
>     mathint x = currentContract@new.foo();
>     assert false;
> }
> ```
> ```
> Example:3:25: @old or @new does not make sense here.
> ```


### `ApplyMethodOnNonContract`

>
> Solidity functions can only be applied from contract instances
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> rule r {
>     mathint x = a.b.foo();
>     assert false;
> }
> ```
> ```
> Example:3:25: Can only apply a method to a contract name, but got 'a.b'
> ```


### `ArraySizeMustBeLiteral`

>
> Static array sizes must be number literals, such as `0` or `10`.  More complex expressions are not allowed.
>
> *No example provided*


### `AtOnNonContractCall`

>
> You may only use the `at storage` syntax for calls to contract functions.  See {ref}`call-expr` for more
> information.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 6-6
> 
> function f() {
> }
> 
> rule r {
>     storage s = lastStorage;
>     f() at s;
>     assert false;
> }
> ```
> ```
> Example:7:13: `at s` may only be used for calls to contract functions; `f` is a CVL function.
> ```


### `DuplicatePreserved`

>
> You may have at most one {ref}`preserved` for each method, at most one generic `preserved` block, and at
> most one `fallback` preserved block.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> invariant i() true {
>     preserved { }
>     preserved  { }
> }
> ```
> ```
> Example:3:13: Invariant `i` has multiple generic preserved blocks (additional block on line 4).
> ```


### `LhsIsDynamicArray`

>
> CVL does not support assigning to an entire array; you can only assign to an entry with a specific index.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> rule example {
>     x[] = 2;
> }
> ```
> ```
> Example:3:17: Assigning to an array element requires an index
> ```


### `LhsIsMapping`

>
> CVL does not support assigning to an entire mapping; you must give individual assignments for the needed elements.
>
> *No example provided*


### `MultipleFiltersSameMethodParam`

>
> There should be only a single filter for each `method`-type parameter
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 1-1
> 
> rule r(method f) filtered { f -> true, f -> true } { assert false; }
> ```
> ```
> Example:2:37: Cannot define multiple filters for the same method parameter `f`.
> ```


### `ReservedKeywordAsFunction`

>
> This error indicates that you tried to use a cast where a function call was expected.  If you want to call a
> contract function with the same name as a keyword, you will need to add a harness function to your contract with
> a different name.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> rule example {
>     uint result = assert_uint256();
> }
> ```
> ```
> Example:3:27: `assert_uint256` is a reserved CVL keyword. Usage: `assert_uint256(valToConvert)`
> ```


### `SyntaxError`

>
> A syntax error indicates a misplaced symbol that prevents the CVL compiler from interpreting a spec file.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 1-1
> 
> rule example oopsie { }
> ```
> ```
> Example:2:22: Syntax error: unexpected token near `oopsie`
> ```


### `TwoStateOnNonGhostFunction`

>
> You can only use `f@old` or `f@new` in the context of a `havoc...assuming` statement, and it can only be applied to a ghost.  See {ref}`havoc-stmt` for more information.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 5-5
> 
> function f(uint x) returns uint {
>     return x;
> }
> rule example {
>     uint y = f@old(0);
> }
> ```
> ```
> Example:6:22: Cannot use `@old` with non-ghost function `f`
> ```


### `UnexpectedToken`

>
> A syntax error. A list of expected tokens is presented
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> ghost f() returns uint {
>     whatever axiom true;
> }
> ```
> ```
> Example:3:13: Syntax error: unexpected token `whatever`; expected `init_state`.
> ```


### `WithWrongNumberArguments`

>
> A `with` must have the form `with(env <variable-name>)`.  See {ref}`with-env` or {ref}`preserved` for more information.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function externalFunction() external with() => summary(e1, e2);
> }
> ```
> ```
> Example:3:50: `with` clause has 0 arguments; `with` clauses must define a single argument of type `env` (e.g. `with(env e)`)
> ```


### `WithWrongType`

>
> A `with` must have the form `with(env <variable-name>)`.  See {ref}`with-env` or {ref}`preserved` for more information.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function externalFunction() external with(uint256 x) => summary(x);
> }
> 
> function summary(uint256 x) {}
> ```
> ```
> Example:3:55: `with` clause argument has type `uint256`; `with` clauses must define a single argument of type `env` (e.g. `with(env e)`)
> ```


### `WithrevertOnNonContractCall`

>
> Only contract functions can be called `@withrevert`; see {ref}`call-expr`.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> function f() {}
> function g() { f@withrevert(); }
> ```
> ```
> Example:3:24: `@withrevert` may only be used for calls to contract functions; `f` is a CVL function.
> ```



## Type-checking errors


### `AssignedToKeyword`

>
> CVL keywords cannot be assigned to.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 1-1
> 
> function f() { nativeBalances = 0; }
> ```
> ```
> Example:2:24: The special CVL variable `nativeBalances` cannot be assigned to.
> ```


### `DeclaredKeyword`

>
> CVL does not allow declaring variables with the same names as keywords.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> function f() {
>     mathint nativeBalances = 0;
> }
> ```
> ```
> Example:3:13: `nativeBalances` is a CVL keyword and cannot be redeclared here.
> ```


### `InconsistentVariableDefinition`

>
> You are allowed to declare a variable and then define it inside the branches of an `if` block.  If you define it
> in one branch, however, you must also define it in the other branch.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 3-7
> 
> function f(bool flag) {
>     mathint x;
>     if (flag) {
>         x = 5;
>     } else {
>         assert true;
>     }
> }
> ```
> ```
> Example:4:13: `x` is defined in the `if` branch (on line 5) but not in the `else` branch.
> ```


### `MethodVariableNotInRule`

>
> Variables of {ref}`method type <method-type>` may only be declared in the top-level of a rule, or as parameters/arguments to a
> rule, CVL function, or definition.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 3-3
> 
> invariant inv() true {
>     preserved externalFunction() with (env e) {
>         method f;
>         require true;
>     }
> }
> ```
> ```
> Example:4:17: `method` variables can only be declared in rules, at their out-most scope.
> ```


### `MethodVariableTooManyContracts`

>
> `method` type variables could only be used under at most a single contract within a given rule.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 3-8
> 
> using SecondaryContract as secondary;
> 
> rule r(method f) {
>     env e; calldataarg args;
>     currentContract.f(e, args);
>     secondary.f(e, args);
>     assert true;
> }
> ```
> ```
> Example:4:9: In rule r there are conflicting usages of `f` - it is marked as being parametric in more than a single contract: [PrimaryContract, SecondaryContract]
> ```


### `NoSuchContractInstance`

>
> When calling a method on a specific contract, the contract must be either `currentContract` or a method-typed
> variable introduced with a `using` statement. See {ref}`call-expr` for more details.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> rule r {
>     d.foo();
>     assert true;
> }
> ```
> ```
> Example:3:15: contract variable `d` not found. Contract variables must be introduced with a `using` statement.
> ```


### `NoValidInstantiationsLeft`

>
> A filter for some method parameter filters out all candidates.
>
> *No example provided*


### `NotConvertible`

>
> This error message indicates that you tried to use a value that cannot be automatically converted to the
> expected type.  You may need to insert an explicit cast.  See {ref}`type-conversions` and {doc}`mathops`
> for more information on types.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> function example(env e) {
>     uint256 x = e;
> }
> ```
> ```
> Example:3:25: `e` has type `env`, which cannot be converted to the expected type `uint256`.
> ```


### `ParametricReturn`

>
> You are not allowed to access the return value of a {term}`parametric method <parametric rule>` call, since the parametric method
> may be resolved to any of several contract methods, and those methods may have different return types.
> 
> Note that this is also true when you call an overloaded contract method with a {ref}`` `calldataarg` <calldataarg>`` argument,
> since this also acts as a parametric method call that calls each of the different overloadings.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 3-3
> 
> rule example {
>     method f; env e; calldataarg args;
>     uint x = f(e,args);
>     assert true;
> }
> ```
> ```
> Example:4:22: You may not access the return value of a call to a `method` variable.
> ```


### `StorageAccessMismatch`

>
> Direct storage access must have restricted forms.
>
> *No example provided*


### `UndeclaredVariable`

>
> All CVL variables must be declared before they are used
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> function f() {
>     mathint y = 2 * x;
> }
> ```
> ```
> Example:3:25: Variable `x` has not been declared.
> ```



## Methods-block errors


### `EnvfreeAndWith`

>
> {ref}`envfree` indicates that a method does not depend on its environment, while a {ref}`with-env`
> allows a function summary to depend on its environment.  Therefore, we disallow including both annotations on
> the same method.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function externalFunction() external envfree with(env e) => summary(e);
> }
> 
> function summary(env e) {}
> ```
> ```
> Example:3:58: `envfree` methods-block entries must not declare a `with(env ...)` clause
> ```


### `InvalidCatchAllFlag`

>
> The annotations that follow the `returns` clause in a methods-block entry (such as {ref}`optional` and
> {ref}`envfree`) only make sense for specific contract functions.  Therefore, their use in catch-all
> summaries of the form `function C._` are disallowed.  If you really want to declare every function `envfree`,
> you will need to add a separate entry for each function.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function C._ envfree => NONDET;
> }
> ```
> ```
> Example:3:26: Catch-all methods entries of the form `function f._` cannot be marked `envfree`
> ```


### `InvalidSummaryForWithClause`

>
> {ref}`with-env` bind a variable name for use in a function summary; without a function summary the clause
> serves no purpose.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function externalFunction() external with(env e) => NONDET;
> }
> ```
> ```
> Example:3:50: `with(...)` clauses are only allowed for methods-block entries with function summaries.
> ```



## CVL 2 errors


### `CVL2MissingFunctionKW`

>
> Since CVL 2, methods block entries must begin with `function`.  See {ref}`cvl2-function-keyword`.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     balanceOf(address);
> }
> ```
> ```
> Example:3:17: Since CVL 2, methods block entries must begin with `function`
> ```


### `CVL2MissingSemicolon`

>
> Indicates one of the places that CVL became more strict about the placement of semicolons.  See {ref}`cvl2-semicolons`.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> methods {
>     function balanceOf(address)
> }
> ```
> ```
> Example:3:40: Since CVL 2, methods block entries must end with `;`
> ```



## Unsupported feature errors


### `AssignedAfterUse`

>
> In CVL, non-ghost variables cannot be given new values once they have been read.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 4-4
> 
> function f() {
>     mathint x;
>     mathint y = x * x;
>     x = 3;
> }
> ```
> ```
> Example:5:13: Assigning to a CVL variable after it is accessed is disallowed; `x` was previously used on line 4.
> ```


### `DuplicateDeclaration`

>
> If a CVL variable is defined in a scope, it cannot be redefined.
>
> Example:
> ```{code-block} cvl
> :emphasize-lines: 2-2
> 
> function f(mathint x) {
>     uint x = 5;
> }
> ```
> ```
> Example:3:13: Redeclaring variables is not supported; `x` was previously declared on line 2
> ```



## CLI options errors


### `ContractChoiceNoSuchContract`

>
> All contracts listed in the `--contract` option must be in the {term}`scene`.
>
> *No example provided*



## Non-specific errors


### `General`

>
> This is a non-specific type of error type; there is not yet additional documentation for these.  If you find
> a particular General error message confusing, please {ref}`contact certora <contact>` and we will try to
> add specific documentation (and also help you out!).
>
> *No example provided*

